
---
import Layout from '../layouts/Layout.astro';
---

<Layout>
  <main>
    <div class="container">
      <div class="column">
        <h1>SVG to XML</h1>
        <div class="input-group">
          <label for="svg-input">SVG Code</label>
          <textarea id="svg-input" rows="10" placeholder="Paste your SVG code here..."></textarea>
        </div>
        <div class="customization-group">
            <div class="input-group">
                <label for="color-input">Color</label>
                <input type="color" id="color-input" value="#000000">
            </div>
            <div class="input-group">
                <label for="width-input">Width</label>
                <input type="number" id="width-input" value="24"><span>dp</span>
            </div>
            <div class="input-group">
                <label for="height-input">Height</label>
                <input type="number" id="height-input" value="24"><span>dp</span>
            </div>
        </div>
      </div>
      <div class="column">
        <div class="preview-group">
            <h2>Preview</h2>
            <div id="preview"></div>
        </div>
        <div class="output-group">
            <h2>XML Output</h2>
            <textarea id="xml-output" readonly placeholder="XML output will appear here..."></textarea>
            <button id="copy-button">Copy to Clipboard</button>
        </div>
      </div>
    </div>
  </main>
</Layout>

<script>
    const svgInput = document.getElementById('svg-input');
    const colorInput = document.getElementById('color-input');
    const widthInput = document.getElementById('width-input');
    const heightInput = document.getElementById('height-input');
    const preview = document.getElementById('preview');
    const xmlOutput = document.getElementById('xml-output');
    const copyButton = document.getElementById('copy-button');

    function convertSvgToXml() {
        const svgCode = svgInput.value;
        if (!svgCode) {
            preview.innerHTML = '';
            xmlOutput.value = '';
            return;
        }

        try {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgCode, 'image/svg+xml');
            const svgElement = svgDoc.querySelector('svg');

            if (!svgElement || svgDoc.querySelector('parsererror')) {
                preview.innerHTML = '<p>Error parsing SVG</p>';
                xmlOutput.value = '';
                return;
            }

            const width = widthInput.value;
            const height = heightInput.value;
            const fillColor = colorInput.value;

            const viewBox = svgElement.getAttribute('viewBox') || `0 0 ${width} ${height}`;
            const viewBoxParts = viewBox.split(' ').map(parseFloat);
            const viewBoxX = viewBoxParts[0] || 0;
            const viewBoxY = viewBoxParts[1] || 0;
            const viewBoxWidth = viewBoxParts[2] || width;
            const viewBoxHeight = viewBoxParts[3] || height;

            let paths = '';
            
            function processElement(element) {
                if (element.nodeType !== 1) return; // Process only element nodes

                const tagName = element.tagName.toLowerCase();
                let pathData = '';
                
                switch(tagName) {
                    case 'path':
                        pathData = element.getAttribute('d');
                        break;
                    case 'rect':
                        const x = parseFloat(element.getAttribute('x') || 0);
                        const y = parseFloat(element.getAttribute('y') || 0);
                        const w = parseFloat(element.getAttribute('width'));
                        const h = parseFloat(element.getAttribute('height'));
                        if (!isNaN(w) && !isNaN(h)) {
                            pathData = `M${x},${y}h${w}v${h}h-${w}z`;
                        }
                        break;
                    case 'circle':
                        const cx = parseFloat(element.getAttribute('cx'));
                        const cy = parseFloat(element.getAttribute('cy'));
                        const r = parseFloat(element.getAttribute('r'));
                        if(!isNaN(cx) && !isNaN(cy) && !isNaN(r)){
                            pathData = `M${cx-r},${cy}a${r},${r} 0 1,0 ${r*2},0a${r},${r} 0 1,0 -${r*2},0`;
                        }
                        break;
                    case 'g':
                        for (const child of element.children) {
                            processElement(child);
                        }
                        break;
                }

                if (pathData) {
                    paths += `
    <path
        android:fillColor="${fillColor}"
        android:pathData="${pathData}"/>`;
                }
            }

            for (const child of svgElement.children) {
                processElement(child);
            }

            let content = paths;
            if (viewBoxX !== 0 || viewBoxY !== 0) {
                content = `
<group
    android:translateX="${-viewBoxX}"
    android:translateY="${-viewBoxY}">${paths}
</group>`;
            }

            const xml = `
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="${width}dp"
    android:height="${height}dp"
    android:viewportWidth="${viewBoxWidth}"
    android:viewportHeight="${viewBoxHeight}">${content}
</vector>
            `;

            xmlOutput.value = xml.trim();
            updatePreview(svgCode, fillColor, width, height);
        } catch (error) {
            console.error(error);
            preview.innerHTML = '<p>Error parsing SVG</p>';
            xmlOutput.value = '';
        }
    }

    function updatePreview(svgCode, color, width, height) {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgCode, 'image/svg+xml');
        const svgElement = svgDoc.querySelector('svg');

        if (svgElement && !svgDoc.querySelector('parsererror')) {
            svgElement.setAttribute('width', width);
            svgElement.setAttribute('height', height);

            const elements = [svgElement, ...svgElement.querySelectorAll('*')];

            elements.forEach(el => {
                const currentFill = el.getAttribute('fill');
                if (currentFill !== 'none') {
                    el.setAttribute('fill', color);
                }
            });

            preview.innerHTML = svgElement.outerHTML;
        } else {
            preview.innerHTML = '';
        }
    }

    svgInput.addEventListener('input', convertSvgToXml);
    colorInput.addEventListener('input', convertSvgToXml);
    widthInput.addEventListener('input', convertSvgToXml);
    heightInput.addEventListener('input', convertSvgToXml);

    copyButton.addEventListener('click', () => {
        xmlOutput.select();
        document.execCommand('copy');
    });

    // Initial conversion for any pasted code
    if(svgInput.value){
        convertSvgToXml();
    }
</script>

<style>
  main {
    padding: 2rem;
  }

  .container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
  }

  .column {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .input-group, .customization-group, .preview-group, .output-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .customization-group{
    flex-direction: row;
    gap: 1rem;
  }

  textarea {
    border-radius: 8px;
    border: 1px solid var(--light-surface-variant);
    padding: 0.5rem;
    background-color: var(--light-surface);
    color: var(--light-on-surface);
    resize: vertical;
  }

  input[type="color"], input[type="number"] {
    border-radius: 8px;
    border: 1px solid var(--light-surface-variant);
    padding: 0.5rem;
    background-color: var(--light-surface);
    color: var(--light-on-surface);
  }
  
  input[type="number"]{
    width: 50px;
  }

  button {
    border-radius: 20px;
    border: none;
    padding: 0.75rem 1.5rem;
    background-color: var(--light-primary);
    color: var(--light-on-primary);
    cursor: pointer;
  }

  #preview {
    border: 1px dashed var(--light-surface-variant);
    border-radius: 8px;
    padding: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100px;
  }

  #xml-output {
    min-height: 200px;
  }
  
  @media (prefers-color-scheme: dark) {
    textarea, input[type="color"], input[type="number"] {
        background-color: var(--dark-surface);
        color: var(--dark-on-surface);
        border-color: var(--dark-surface-variant);
    }

    button {
        background-color: var(--dark-primary);
        color: var(--dark-on-primary);
    }

    #preview {
        border-color: var(--dark-surface-variant);
    }
  }
</style>
